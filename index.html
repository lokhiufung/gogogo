<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Go (Weiqi/Baduk) — 2 Players</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151821;
    --accent: #7aa2f7;
    --text: #e5e7eb;
    --muted: #9aa1ad;
    --warn: #f59e0b;
    --danger: #ef4444;
    --ok: #10b981;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: var(--bg); color: var(--text);
    font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    display: grid; min-height: 100dvh; grid-template-rows: auto 1fr auto;
  }
  header, footer {
    padding: 10px 14px; background: var(--panel); border-bottom: 1px solid #1f2430;
  }
  header h1 { margin: 0; font-size: 16px; font-weight: 600; }
  header small { color: var(--muted); }
  main { display: grid; grid-template-columns: 1fr 320px; gap: 12px; padding: 12px; }
  @media (max-width: 900px) {
    main { grid-template-columns: 1fr; }
  }
  .board-wrap {
    background: #deb887; /* wood vibe */
    border-radius: 10px; padding: 10px; box-shadow: 0 6px 24px rgba(0,0,0,.35) inset, 0 4px 14px rgba(0,0,0,.25);
    display: grid;
  }
  canvas { width: 100%; height: auto; aspect-ratio: 1 / 1; touch-action: manipulation; border-radius: 8px; }
  .side {
    background: var(--panel); border-radius: 12px; padding: 12px;
    display: grid; gap: 10px; align-content: start;
  }
  .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .row label { color: var(--muted); }
  select, button {
    appearance: none; border: 1px solid #2a3040; background: #0f131b; color: var(--text);
    padding: 8px 10px; border-radius: 10px; cursor: pointer;
  }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .btn-primary { background: var(--accent); border-color: #5478e9; color: #0b1020; font-weight: 600; }
  .btn-warn { background: var(--warn); border-color: #b7791f; color: #1a1405; }
  .btn-danger { background: var(--danger); border-color: #b91c1c; color: #1a0909; }
  .btn-ghost { background: #0f131b; }
  .pill {
    display: inline-flex; gap: 6px; align-items: center; padding: 6px 10px; border-radius: 999px;
    background: #0f131b; border: 1px solid #2a3040; color: var(--muted);
  }
  .stone {
    width: 14px; height: 14px; border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,.4) inset, 0 1px 0 rgba(255,255,255,.15);
  }
  .stone.black { background: radial-gradient(circle at 35% 35%, #444 0%, #111 60%, #000 100%); }
  .stone.white { background: radial-gradient(circle at 35% 35%, #fff 0%, #e5e5e5 60%, #cfcfcf 100%); border: 1px solid #ddd; }
  .log {
    max-height: 30vh; overflow: auto; border: 1px dashed #2a3040; border-radius: 8px; padding: 8px; background: #0b0e14;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;
  }
  .score { padding: 8px; border: 1px solid #2a3040; border-radius: 10px; background: #0b0f17; }
  .score h3 { margin: 0 0 6px; font-size: 14px; }
  .hint { color: var(--muted); font-size: 12px; }
</style>
</head>
<body>
<header>
  <h1>Go — 2 Players <small>(pure HTML/CSS/JS)</small></h1>
</header>

<main>
  <div class="board-wrap">
    <canvas id="goCanvas" width="1200" height="1200" aria-label="Go board" role="img"></canvas>
  </div>

  <aside class="side">
    <div class="row" aria-live="polite">
      <span class="pill" id="turnPill">
        <span class="stone black" id="turnStone"></span>
        <b id="turnText">Black to move</b>
      </span>
      <span class="pill" title="Captures by Black"><span class="stone black"></span>×<span id="capBlack">0</span></span>
      <span class="pill" title="Captures by White"><span class="stone white"></span>×<span id="capWhite">0</span></span>
    </div>

    <div class="row">
      <label for="sizeSel">Board:</label>
      <select id="sizeSel">
        <option value="9">9×9</option>
        <option value="13">13×13</option>
        <option value="19" selected>19×19</option>
      </select>
      <button class="btn-ghost" id="newBtn" title="Start a new game with selected board size">New</button>
      <button id="undoBtn">Undo</button>
    </div>

    <div class="row">
      <button class="btn-primary" id="passBtn">Pass</button>
      <button class="btn-warn" id="scoreBtn" title="Score now (also happens after two passes)">Score</button>
      <button class="btn-danger" id="resignBtn">Resign</button>
    </div>

    <div class="score" id="scoreBox" hidden>
      <h3>Score (Tromp–Taylor area):</h3>
      <div id="scoreText"></div>
      <div class="hint">Area scoring = Stones on board + Surrounded empty intersections.</div>
    </div>

    <div class="log" id="log" aria-live="polite"></div>
    <div class="hint">Tips: Tap/click intersections to place stones. Suicide is not allowed. Simple ko rule in effect. Two passes end the game and trigger scoring.</div>
  </aside>
</main>

<footer>
  <small>Made with ❤️ in plain JS. No libraries. </small>
</footer>

<script>
(() => {
  // --- Game State ---
  const canvas = document.getElementById('goCanvas');
  const ctx = canvas.getContext('2d');
  const turnStone = document.getElementById('turnStone');
  const turnText  = document.getElementById('turnText');
  const capBlackEl = document.getElementById('capBlack');
  const capWhiteEl = document.getElementById('capWhite');
  const sizeSel = document.getElementById('sizeSel');
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const passBtn = document.getElementById('passBtn');
  const resignBtn = document.getElementById('resignBtn');
  const scoreBtn = document.getElementById('scoreBtn');
  const scoreBox = document.getElementById('scoreBox');
  const scoreText = document.getElementById('scoreText');
  const logEl = document.getElementById('log');

  let N = 19;                // board size
  let board = [];            // 0 empty, 1 black, 2 white
  let toPlay = 1;            // 1 black, 2 white
  let captures = {1:0, 2:0}; // stones captured by color
  let passesInRow = 0;
  let koPoint = null;        // {i,j} forbidden for one move if simple ko
  let history = [];          // stack of states for undo
  let gameOver = false;

  // drawing parameters
  let pad; let cell; let pxRatio;

  function initBoard(size) {
    N = size;
    board = Array.from({length:N}, () => Array(N).fill(0));
    toPlay = 1;
    captures = {1:0, 2:0};
    passesInRow = 0;
    koPoint = null;
    history = [];
    gameOver = false;
    scoreBox.hidden = true;
    logEl.textContent = '';
    log(`New ${N}×${N} game. Black to move.`);
    updateUI();
    resizeCanvas();
    draw();
  }

  function log(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    logEl.textContent += line;
    logEl.scrollTop = logEl.scrollHeight;
  }

  // --- Utilities ---
  function cloneBoard(b = board) {
    return b.map(r => r.slice());
  }
  function pushHistory() {
    history.push({
      board: cloneBoard(),
      toPlay,
      captures: {...captures},
      koPoint: koPoint ? {...koPoint} : null,
      passesInRow,
      gameOver
    });
  }
  function popHistory() {
    const s = history.pop();
    if (!s) return;
    board = s.board;
    toPlay = s.toPlay;
    captures = s.captures;
    koPoint = s.koPoint;
    passesInRow = s.passesInRow;
    gameOver = s.gameOver;
    scoreBox.hidden = true;
    updateUI();
    draw();
  }

  function neighbors(i,j) {
    const res = [];
    if (i>0) res.push([i-1,j]);
    if (i<N-1) res.push([i+1,j]);
    if (j>0) res.push([i,j-1]);
    if (j<N-1) res.push([i,j+1]);
    return res;
  }

  function groupAndLiberties(si,sj) {
    const color = board[si][sj];
    if (!color) return {stones:[], liberties:0};
    const stack = [[si,sj]];
    const seen = new Set([si+','+sj]);
    const stones = [];
    const libsSet = new Set();
    while (stack.length) {
      const [i,j] = stack.pop();
      stones.push([i,j]);
      for (const [ni,nj] of neighbors(i,j)) {
        const v = board[ni][nj];
        if (v === 0) {
          libsSet.add(ni+','+nj);
        } else if (v === color) {
          const key = ni+','+nj;
          if (!seen.has(key)) {
            seen.add(key);
            stack.push([ni,nj]);
          }
        }
      }
    }
    return {stones, liberties: libsSet.size};
  }

  function removeStones(list) {
    for (const [i,j] of list) board[i][j] = 0;
  }

  function play(i,j) {
    if (gameOver) return;
    if (i<0||i>=N||j<0||j>=N) return;
    if (board[i][j] !== 0) return;
    if (koPoint && koPoint.i===i && koPoint.j===j) {
      log(`Illegal: ko at (${i+1},${j+1}).`);
      return;
    }

    pushHistory();

    board[i][j] = toPlay;
    // capture opponent groups with no liberties
    const opp = 3 - toPlay;
    let totalCaptured = 0;
    let capturedCoords = [];
    for (const [ni,nj] of neighbors(i,j)) {
      if (board[ni][nj] === opp) {
        const g = groupAndLiberties(ni,nj);
        if (g.liberties === 0) {
          totalCaptured += g.stones.length;
          capturedCoords.push(...g.stones);
          removeStones(g.stones);
        }
      }
    }
    // check suicide (not allowed) unless we captured something
    const gSelf = groupAndLiberties(i,j);
    if (gSelf.liberties === 0 && totalCaptured === 0) {
      // revert
      popHistory(); // revert push & placement
      log(`Illegal: suicide at (${i+1},${j+1}).`);
      return;
    }

    // update ko (simple): if exactly one stone captured, set ko at that point, else clear
    koPoint = null;
    if (totalCaptured === 1) {
      const [ci, cj] = capturedCoords[0];
      koPoint = {i: ci, j: cj};
    }

    captures[toPlay] += totalCaptured;
    passesInRow = 0;
    log(`${toPlay===1?'Black':'White'} played ${coordLabel(i,j)}${totalCaptured?` and captured ${totalCaptured}`:''}.`);
    toPlay = 3 - toPlay;

    updateUI();
    draw();
  }

  function pass() {
    if (gameOver) return;
    pushHistory();
    passesInRow++;
    log(`${toPlay===1?'Black':'White'} passes.`);
    toPlay = 3 - toPlay;
    koPoint = null;
    updateUI();
    if (passesInRow >= 2) {
      gameOver = true;
      log(`Both players passed. Game over — scoring…`);
      scoreNow();
    }
  }

  function resign() {
    if (gameOver) return;
    gameOver = true;
    log(`${toPlay===1?'Black':'White'} resigns. ${toPlay===1?'White':'Black'} wins.`);
    scoreBox.hidden = false;
    scoreText.innerHTML = `<b>${toPlay===1?'White':'Black'} wins by resignation.</b>`;
  }

  function scoreNow() {
    const res = trompTaylorScore();
    const b = res.black, w = res.white;
    const winner = b > w ? 'Black' : (w > b ? 'White' : 'No one');
    const diff = Math.abs(b - w).toFixed(1);
    scoreBox.hidden = false;
    scoreText.innerHTML =
      `Black: <b>${b.toFixed(1)}</b> &nbsp; White: <b>${w.toFixed(1)}</b><br/>
       Stones (B/W): ${res.stones.black} / ${res.stones.white}<br/>
       Territory (B/W): ${res.territory.black} / ${res.territory.white}<br/>
       <b>${winner} ${winner==='No one'?'— draw':'wins by ' + diff}</b>`;
  }

  function trompTaylorScore() {
    // Area = stones on board + surrounded empty
    let stonesBlack = 0, stonesWhite = 0;
    for (let i=0;i<N;i++) for (let j=0;j<N;j++) {
      if (board[i][j] === 1) stonesBlack++;
      if (board[i][j] === 2) stonesWhite++;
    }
    let terrBlack = 0, terrWhite = 0;
    const seen = Array.from({length:N}, ()=>Array(N).fill(false));
    for (let i=0;i<N;i++) for (let j=0;j<N;j++) {
      if (board[i][j] !== 0 || seen[i][j]) continue;
      const q = [[i,j]];
      seen[i][j] = true;
      const empties = [[i,j]];
      let touches = new Set();
      while (q.length) {
        const [ci,cj] = q.pop();
        for (const [ni,nj] of neighbors(ci,cj)) {
          const v = board[ni][nj];
          if (v === 0 && !seen[ni][nj]) {
            seen[ni][nj] = true;
            q.push([ni,nj]);
            empties.push([ni,nj]);
          } else if (v === 1) touches.add(1);
          else if (v === 2) touches.add(2);
        }
      }
      if (touches.size === 1) {
        const owner = touches.has(1) ? 1 : 2;
        if (owner === 1) terrBlack += empties.length;
        else terrWhite += empties.length;
      }
    }
    return {
      black: stonesBlack + terrBlack,
      white: stonesWhite + terrWhite,
      stones: {black: stonesBlack, white: stonesWhite},
      territory: {black: terrBlack, white: terrWhite}
    };
  }

  function coordLabel(i,j) {
    // SGF-ish: letters skipping I; here simple A.. for columns
    const letters = [];
    for (let k=0;k<26;k++) letters.push(String.fromCharCode(65+k));
    const colLetter = (j<8) ? letters[j] : letters[j+1]; // skip 'I'
    return `${colLetter}${N - i}`;
  }

  // --- Drawing ---
  function resizeCanvas() {
    // Fit devicePixelRatio
    const parent = canvas.getBoundingClientRect();
    const dim = Math.floor(Math.min(parent.width, parent.height || parent.width));
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    canvas.width = dim * dpr;
    canvas.height = dim * dpr;
    pxRatio = dpr;
    // layout
    const w = canvas.width;
    pad = Math.round(w * 0.07);            // outer margin
    const inner = w - pad*2;
    cell = Math.round(inner / (N-1));      // grid spacing
    // recalc inner to perfectly fit N-1 cells
    const used = cell * (N-1);
    const extra = inner - used;
    pad += Math.floor(extra/2);
    draw();
  }

  function draw() {
    const w = canvas.width, h = canvas.height;
    // wood background already in container; draw board area
    ctx.clearRect(0,0,w,h);

    // star points by size
    const starPoints = (N===19) ? [3,9,15] : (N===13 ? [3,6,9] : (N===9 ? [2,4,6] : []));
    // grid
    ctx.save();
    // subtle radial gradient backdrop
    const grad = ctx.createRadialGradient(w/2,h/2, w*0.05, w/2,h/2, w*0.55);
    grad.addColorStop(0, '#e6c07b');
    grad.addColorStop(1, '#d2ab68');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // grid lines
    ctx.strokeStyle = '#1b1408';
    ctx.lineWidth = Math.max(1, Math.floor(1.2 * pxRatio));

    for (let k=0;k<N;k++) {
      const x = pad + k*cell;
      const y0 = pad, y1 = pad + (N-1)*cell;
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
      const y = pad + k*cell;
      const x0 = pad, x1 = pad + (N-1)*cell;
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    }

    // star points
    ctx.fillStyle = '#111';
    const rStar = Math.max(2, Math.floor(2.2 * pxRatio));
    for (const ix of starPoints) for (const iy of starPoints) {
      const x = pad + ix*cell, y = pad + iy*cell;
      ctx.beginPath(); ctx.arc(x,y,rStar,0,Math.PI*2); ctx.fill();
    }

    // ko marker
    if (koPoint) {
      const x = pad + koPoint.j*cell, y = pad + koPoint.i*cell;
      ctx.strokeStyle = '#e11d48';
      ctx.lineWidth = Math.max(2, Math.floor(2 * pxRatio));
      ctx.beginPath(); ctx.arc(x,y, Math.floor(cell*0.18), 0, Math.PI*2); ctx.stroke();
    }

    // stones
    for (let i=0;i<N;i++) for (let j=0;j<N;j++) {
      if (board[i][j] === 0) continue;
      drawStone(i,j, board[i][j]);
    }

    ctx.restore();
  }

  function drawStone(i,j,color) {
    const x = pad + j*cell;
    const y = pad + i*cell;
    const r = Math.floor(cell*0.44);

    // shadow
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y + Math.floor(r*0.08), r, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fill();

    // stone body with radial highlight
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    const g = ctx.createRadialGradient(x - r*0.35, y - r*0.35, r*0.1, x,y,r);
    if (color === 1) {
      g.addColorStop(0, '#444');
      g.addColorStop(0.6, '#1a1a1a');
      g.addColorStop(1, '#000');
    } else {
      g.addColorStop(0, '#fff');
      g.addColorStop(0.6, '#e5e5e5');
      g.addColorStop(1, '#cfcfcf');
    }
    ctx.fillStyle = g;
    ctx.fill();

    // subtle rim
    ctx.lineWidth = Math.max(1, Math.floor(pxRatio));
    ctx.strokeStyle = (color===1) ? '#000' : '#ddd';
    ctx.stroke();

    ctx.restore();
  }

  // --- Input handling ---
  function canvasToCell(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    // convert to canvas pixel space with dpr
    const x = (clientX - rect.left) * pxRatio;
    const y = (clientY - rect.top) * pxRatio;

    // find nearest intersection by rounding to nearest grid node
    const j = Math.round((x - pad) / cell);
    const i = Math.round((y - pad) / cell);

    if (i<0||i>=N||j<0||j>=N) return null;

    // require click proximity to the grid node (within 0.45 cell)
    const nx = pad + j*cell, ny = pad + i*cell;
    const dist = Math.hypot(nx - x, ny - y);
    if (dist > cell*0.45) return null;
    return {i,j};
  }

  canvas.addEventListener('click', (e) => {
    const cellPos = canvasToCell(e.clientX, e.clientY);
    if (!cellPos) return;
    play(cellPos.i, cellPos.j);
  }, {passive:true});

  // touch support
  canvas.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const cellPos = canvasToCell(t.clientX, t.clientY);
    if (!cellPos) return;
    play(cellPos.i, cellPos.j);
  }, {passive:true});

  window.addEventListener('resize', resizeCanvas);

  // --- UI controls ---
  newBtn.addEventListener('click', () => {
    initBoard(parseInt(sizeSel.value,10));
  });
  sizeSel.addEventListener('change', () => {
    initBoard(parseInt(sizeSel.value,10));
  });
  undoBtn.addEventListener('click', () => {
    popHistory();
  });
  passBtn.addEventListener('click', () => {
    pass();
  });
  resignBtn.addEventListener('click', () => {
    resign();
  });
  scoreBtn.addEventListener('click', () => {
    scoreNow();
  });

  function updateUI() {
    capBlackEl.textContent = String(captures[1]);
    capWhiteEl.textContent = String(captures[2]);
    turnStone.className = 'stone ' + (toPlay===1?'black':'white');
    turnText.textContent = gameOver ? 'Game Over' : ((toPlay===1?'Black':'White') + ' to move');
  }

  // --- Start ---
  initBoard(N);
})();
</script>
</body>
</html>